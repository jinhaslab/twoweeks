[["data-manipulation.html", "Chapter 5 Data Manipulation 5.1 dplyr (tidyverse) 5.2 실습 데이터 준비 5.3 select 5.4 filter 5.5 arrange 5.6 mutate 5.7 group_by 5.8 merge, join", " Chapter 5 Data Manipulation 5.1 dplyr (tidyverse) 데이터를 모으는 입장과 데이터를 분석하는 입장은 매우 다릅니다. 데이터를 모을 때는 모으는 연구자의 입장에서 하게되고, 이를 분석하는 연구자에 맞도록 변형하는 과정이 필요합니다. 또한 표를 만들거나 도표를 만드는 과정에서 데이터의 모양을 우리가 원하는 데로 변형할 필요가 있습니다. R에서 이과정을 쉽게 하기 위해 가장 많이 사용되는 것이 dplyr (tidyverse) 입니다. 이를 이용해서 실습해 보겠습니다 if(!require(&quot;tidyverse&quot;)) install.packages(&quot;tidyverse&quot;) if(!require(&quot;htmlTable&quot;)) install.packages(&quot;htmlTable&quot;) if(!require(&quot;haven&quot;)) install.packages(&quot;haven&quot;) if(!require(&quot;DT&quot;)) install.packages(&quot;DT&quot;) 5.2 실습 데이터 준비 데이터 표를 만드는 실습은 6차 근로환경조사 자료를 통해 실습할 것입니다.. 자료는 안전보건공단, 근로환경조사 원시자료 사이트 (http://kosha.or.kr/kosha/data/primitiveData.do) 에서 신청할 수 있습니다.. 데이터를 불러오겠습니다. 안전보건공단 홈페이에서 자료를 다운 받는게 원칙입니다. 다만 실습을 빠르게 진행하기 위해서, dspubs.org 페이지에 있는 파일을 이용하겠습니다. dspubs.org open_data 자신의 folder에 data 라는 folder가 있는지 확인하십시오. data라는 폴더에 다운로드하고, 불러오도록 하겠습니다. url &lt;- &quot;https://dspubs.org/webapps/forum/open_data/kwcs6th.sav&quot; download.file(url, &quot;data/kwcs6th.sav&quot;) kwcs &lt;- read_sav(&quot;data/kwcs6th.sav&quot;) 데이터 10개만 살펴보겠습니다. 이때 head()는 처음 10개, tail() 은 뒤에 10개, slice(5:15) 은 5번째부터 15번째 까지 입니다. kwcs %&gt;% head() %&gt;% DT::datatable() &gt; 설문지와 변수설명 파일은 아래와 같습니다. 설문지 변수설명 파일 5.3 select 필요한 데이터를 종으로, columns 로 분할하는 것입니다. 즉 변수명으로 데이터를 분할하는 것입니다. 선택될 변수는 변수명과 변수번호(왼쪽 부터 1번)를 이용해서 할 수 있습니다. 처음부터 5번째 변수까지 선택해 보겠습니다 . kwcs %&gt;% select(1:5) kwcs %&gt;% select(id, wt, area, hh_num, hm_01_gender) ## # A tibble: 6 × 5 ## id wt area hh_num hm_01_gender ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt; ## 1 1 0.515 12 [충남] 2 1 [남성] ## 2 2 0.137 3 [대구] 1 2 [여성] ## 3 3 0.350 3 [대구] 1 2 [여성] ## 4 4 0.212 6 [대전] 3 1 [남성] ## 5 5 0.191 6 [대전] 2 1 [남성] ## 6 6 0.156 7 [울산] 1 2 [여성] 변수명에 job이 들어 있는 경우 선택해 보겠습니다. kwcs %&gt;% select(contains(&quot;job&quot;)) %&gt;% head() ## # A tibble: 6 × 11 ## job1 job2 job3 job3_…¹ comp_s…² job_c1 job_c1…³ job_c…⁴ job_c…⁵ job_c2 ## &lt;dbl+lb&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl+lb&gt; &lt;dbl+&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; ## 1 1 [1개] NA NA &quot;&quot; NA … NA 1 [가… NA NA NA … ## 2 1 [1개] NA NA &quot;&quot; 2 [대… 60 NA … NA NA 1 [그… ## 3 1 [1개] NA NA &quot;&quot; NA … 70 NA … NA NA NA … ## 4 1 [1개] NA NA &quot;&quot; 1 [대… NA 1 [가… NA NA NA … ## 5 1 [1개] NA NA &quot;&quot; NA … NA 1 [가… NA NA NA … ## 6 1 [1개] NA NA &quot;&quot; 1 [대… 70 NA … NA NA NA … ## # … with 1 more variable: job_c3 &lt;dbl+lbl&gt;, and abbreviated variable names ## # ¹​job3_etc, ²​comp_sjob, ³​job_c1_666, ⁴​job_c1_888, ⁵​job_c1_999 select안에서는 ” ” 안에 문자가 변수 명으로 인식됩니다. 이것은 매우 중요한 개념입니다. 아래의 두 코드는 같은 결과를 줍니다. 외부에서 문자를 입력 받았어도, 바로 적용할 수 있다는 의미 입니다. kwcs %&gt;% select(&quot;job1&quot;) ## # A tibble: 50,538 × 1 ## job1 ## &lt;dbl+lbl&gt; ## 1 1 [1개] ## 2 1 [1개] ## 3 1 [1개] ## 4 1 [1개] ## 5 1 [1개] ## 6 1 [1개] ## 7 1 [1개] ## 8 1 [1개] ## 9 1 [1개] ## 10 1 [1개] ## # … with 50,528 more rows kwcs %&gt;% select(job1) ## # A tibble: 50,538 × 1 ## job1 ## &lt;dbl+lbl&gt; ## 1 1 [1개] ## 2 1 [1개] ## 3 1 [1개] ## 4 1 [1개] ## 5 1 [1개] ## 6 1 [1개] ## 7 1 [1개] ## 8 1 [1개] ## 9 1 [1개] ## 10 1 [1개] ## # … with 50,528 more rows 제외하는 방법은 -를 사용합니다. test &lt;- kwcs %&gt;% select(id, wt, area) %&gt;% head() test ## # A tibble: 6 × 3 ## id wt area ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl+lbl&gt; ## 1 1 0.515 12 [충남] ## 2 2 0.137 3 [대구] ## 3 3 0.350 3 [대구] ## 4 4 0.212 6 [대전] ## 5 5 0.191 6 [대전] ## 6 6 0.156 7 [울산] test라는 데이터셑을 만들었습니다. id, wt, area라는 변수를 갖은 데이터 입니다. 여기서 id라는 변수를 제외하겠습니다. test %&gt;% select(-1) ## # A tibble: 6 × 2 ## wt area ## &lt;dbl&gt; &lt;dbl+lbl&gt; ## 1 0.515 12 [충남] ## 2 0.137 3 [대구] ## 3 0.350 3 [대구] ## 4 0.212 6 [대전] ## 5 0.191 6 [대전] ## 6 0.156 7 [울산] test %&gt;% select(-id) ## # A tibble: 6 × 2 ## wt area ## &lt;dbl&gt; &lt;dbl+lbl&gt; ## 1 0.515 12 [충남] ## 2 0.137 3 [대구] ## 3 0.350 3 [대구] ## 4 0.212 6 [대전] ## 5 0.191 6 [대전] ## 6 0.156 7 [울산] 5.4 filter filter 는 특정 조건에 해당하는 행(row)를 선택합니다. 예를 들어 성별 중 남성만, 여성만 선택한 다는가 특정 연령 범위를 선택합니다. 이때 몇몇 조건문을 사용합니다. ==은 같다는 뜻입니다. 아래와 같이 활용합니다. kwcs %&gt;% select(TSEX, AGE) %&gt;% filter(AGE ==55) %&gt;% head() ## # A tibble: 6 × 2 ## TSEX AGE ## &lt;dbl+lbl&gt; &lt;dbl&gt; ## 1 2 [여성] 55 ## 2 2 [여성] 55 ## 3 2 [여성] 55 ## 4 1 [남성] 55 ## 5 1 [남성] 55 ## 6 1 [남성] 55 &amp;는 and |는 or 을 의미합니다. 성별과 연령을 동시에 조건을 주도록 하겠습니다. kwcs %&gt;% select(TSEX, AGE) %&gt;% filter(TSEX ==1 &amp; AGE &lt;17) # or == | ## # A tibble: 4 × 2 ## TSEX AGE ## &lt;dbl+lbl&gt; &lt;dbl&gt; ## 1 1 [남성] 16 ## 2 1 [남성] 16 ## 3 1 [남성] 16 ## 4 1 [남성] 16 !는 아니라는 표시입니다. 이것을 통해서 간단하게 여러 조건을 생략시킬 수 있습니다. kwcs %&gt;% select(TSEX, AGE) %&gt;% filter(TSEX !=1) %&gt;% filter(AGE &gt;=16 &amp; AGE &lt;18) ## # A tibble: 9 × 2 ## TSEX AGE ## &lt;dbl+lbl&gt; &lt;dbl&gt; ## 1 2 [여성] 16 ## 2 2 [여성] 17 ## 3 2 [여성] 17 ## 4 2 [여성] 17 ## 5 2 [여성] 17 ## 6 2 [여성] 16 ## 7 2 [여성] 17 ## 8 2 [여성] 17 ## 9 2 [여성] 17 %in%를 사용하면 여러 조건을 나열하는 방법으로 선택할 수 있습니다. 명목변수 등에 사용하기 편합니다. kwcs %&gt;% select(TSEX, AGE) %&gt;% filter(TSEX %in% c(1, 2)) %&gt;% # %in% allow multiple filtering filter(!AGE &gt;16) # ! means negative condition ## # A tibble: 8 × 2 ## TSEX AGE ## &lt;dbl+lbl&gt; &lt;dbl&gt; ## 1 1 [남성] 16 ## 2 2 [여성] 16 ## 3 1 [남성] 16 ## 4 1 [남성] 16 ## 5 2 [여성] 16 ## 6 1 [남성] 16 ## 7 2 [여성] 15 ## 8 2 [여성] 15 5.5 arrange arrange는 순차 정렬하는 함수입니다. 정방향, 역방향이 가능합니다. kwcs %&gt;% select(AGE) %&gt;% arrange(AGE) %&gt;% head() ## # A tibble: 6 × 1 ## AGE ## &lt;dbl&gt; ## 1 15 ## 2 15 ## 3 16 ## 4 16 ## 5 16 ## 6 16 kwcs %&gt;% select(AGE) %&gt;% arrange(desc(AGE)) %&gt;% head() ## # A tibble: 6 × 1 ## AGE ## &lt;dbl&gt; ## 1 96 ## 2 95 ## 3 93 ## 4 92 ## 5 92 ## 6 92 5.6 mutate mutate는 변수를 변형하는 가장 기본이면서 자주 사용되는 함수 입니다. 반드시 익숙해여쟈 하는 함수 입니다. mutate 단독으로 쓰이기 보다는 여러 조건문인 ifelse, case_when, recode를 이용합니다. 될수 있으면 ifelse보다는 case_when을 이용하는 것이 향후 SQL 등을 사용할 때 더 편할 수 있어 추천합니다. 남녀가 현재는 1인 남자, 2가 여자 입니다. 이를 male, female로 바꾸겠습니다. kwcs %&gt;% select(TSEX, AGE) %&gt;% mutate(sexgp = case_when( TSEX==1 ~ &#39;male&#39;, TSEX==2 ~ &#39;female&#39; )) %&gt;% head() ## # A tibble: 6 × 3 ## TSEX AGE sexgp ## &lt;dbl+lbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2 [여성] 74 female ## 2 2 [여성] 54 female ## 3 2 [여성] 64 female ## 4 1 [남성] 78 male ## 5 1 [남성] 78 male ## 6 2 [여성] 65 female 이번에는 연령을 5세 단위로 바꾸어 보겠습니다. 그리고 test1이라는 데이터로 변형시켜보겠습니다. test1 = kwcs %&gt;% select(TSEX, AGE) %&gt;% mutate(sexgp = case_when( TSEX==1 ~ &#39;male&#39;, TSEX==2 ~ &#39;female&#39; )) %&gt;% mutate(agegp = case_when( AGE &lt;25 ~ &quot;&lt;25&quot;, AGE &lt;30 ~ &quot;&lt;30&quot;, AGE &lt;35 ~ &quot;&lt;35&quot;, AGE &lt;40 ~ &quot;&lt;40&quot;, AGE &lt;45 ~ &quot;&lt;45&quot;, AGE &lt;50 ~ &quot;&lt;50&quot;, AGE &lt;55 ~ &quot;&lt;55&quot;, AGE &lt;60 ~ &quot;&lt;60&quot;, TRUE ~ &quot;\\u226560&quot; # 나머지는 모두 &gt;65 (\\u2265는 크거나 같다는 symbol) )) %&gt;% slice(1:10) test1에는 sexgp가 female , male 이라고 되어 있네요, 이때 female을 Female로 대문자 변화, male을 Male로 대문자 변환해 보겠습니다. recode를 사용하겠습니다. test1 ## # A tibble: 10 × 4 ## TSEX AGE sexgp agegp ## &lt;dbl+lbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 [여성] 74 female ≥60 ## 2 2 [여성] 54 female &lt;55 ## 3 2 [여성] 64 female ≥60 ## 4 1 [남성] 78 male ≥60 ## 5 1 [남성] 78 male ≥60 ## 6 2 [여성] 65 female ≥60 ## 7 1 [남성] 61 male ≥60 ## 8 2 [여성] 57 female &lt;60 ## 9 1 [남성] 38 male &lt;40 ## 10 2 [여성] 47 female &lt;50 만연 female, male 두개뿐이라면 이 방법이 쉬울 수 있습니다. case_when과 female, male을 적절히 사용하면 되겠습니다. test1 %&gt;% mutate(Sexgp = recode(sexgp, &quot;female&quot; = &quot;Female&quot;, &quot;male&quot; = &quot;Male&quot;)) ## # A tibble: 10 × 5 ## TSEX AGE sexgp agegp Sexgp ## &lt;dbl+lbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 [여성] 74 female ≥60 Female ## 2 2 [여성] 54 female &lt;55 Female ## 3 2 [여성] 64 female ≥60 Female ## 4 1 [남성] 78 male ≥60 Male ## 5 1 [남성] 78 male ≥60 Male ## 6 2 [여성] 65 female ≥60 Female ## 7 1 [남성] 61 male ≥60 Male ## 8 2 [여성] 57 female &lt;60 Female ## 9 1 [남성] 38 male &lt;40 Male ## 10 2 [여성] 47 female &lt;50 Female 60세 미만을 young, 60세 이상을 old로 구분하여 young female, old female, young male, old male로 바꾸어 보겠습니다. case_when에는 처음에 사용한 것을 제외하고 나머지에서라는 뜻이 포함되어 있지요. 즉 ifelse 가 이미 숨어있습니다. test1 %&gt;% mutate(intgp = case_when( AGE &lt;60 &amp; TSEX == 1 ~ &quot;young male&quot;, AGE &lt;60 &amp; TSEX == 2 ~ &quot;young female&quot;, TSEX == 1 ~ &quot;old male&quot;, TSEX == 2 ~ &quot;old female&quot; )) ## # A tibble: 10 × 5 ## TSEX AGE sexgp agegp intgp ## &lt;dbl+lbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 [여성] 74 female ≥60 old female ## 2 2 [여성] 54 female &lt;55 young female ## 3 2 [여성] 64 female ≥60 old female ## 4 1 [남성] 78 male ≥60 old male ## 5 1 [남성] 78 male ≥60 old male ## 6 2 [여성] 65 female ≥60 old female ## 7 1 [남성] 61 male ≥60 old male ## 8 2 [여성] 57 female &lt;60 young female ## 9 1 [남성] 38 male &lt;40 young male ## 10 2 [여성] 47 female &lt;50 young female 5.7 group_by group_by는 데이터 탐색에서 가장 많이 사용되면, 연속변수는 summrise와 명목변수는 count와 같이 사용됩니다. group_by에 의해 변수값에 따라 정리가 되게 됩니다. 새로운 변수은 heal_prob1를 사용해 보겠습니다. heal_prob1는 요통여 부이고, 요통이 있으면 1, 없으면 2로 되어 있습니다. 결측값, 무응답이 많으니 heal_prob1 에 무응답이 있는 경우 제외하겠습니다. NA 결측값은 is.na(변수)로 찾을 수 있습니다. 우선 count로 해보겠습니다 . kwcs %&gt;% count(heal_prob1) ## # A tibble: 3 × 2 ## heal_prob1 n ## &lt;dbl+lbl&gt; &lt;int&gt; ## 1 1 [있다] 16136 ## 2 2 [없다] 34343 ## 3 NA 59 NA가 59개 있네요. 아래와 같이 sexgp별로 요통을 호소하는 사람이 얼마나 있는지 확인해 보겠습니다. kwcs %&gt;% filter(!is.na(heal_prob1)) %&gt;% # is.na() 즉 NA이면에서 !는 NA가 아니면이라는 뜻 select(TSEX, AGE, heal_prob1) %&gt;% mutate(sexgp=case_when( TSEX==1 ~ &quot;Men&quot;, TRUE ~ &quot;Female&quot; )) %&gt;% group_by(sexgp) %&gt;% count(heal_prob1) ## # A tibble: 4 × 3 ## # Groups: sexgp [2] ## sexgp heal_prob1 n ## &lt;chr&gt; &lt;dbl+lbl&gt; &lt;int&gt; ## 1 Female 1 [있다] 9507 ## 2 Female 2 [없다] 17257 ## 3 Men 1 [있다] 6629 ## 4 Men 2 [없다] 17086 연령별로는 어떠한 비율인지 확인해 보겠습니다. kwcs %&gt;% filter(!is.na(heal_prob1)) %&gt;% # is.na() 즉 NA이면에서 !는 NA가 아니면이라는 뜻 select(TSEX, AGE, heal_prob1) %&gt;% mutate(sexgp=case_when( TSEX==1 ~ &quot;Men&quot;, TRUE ~ &quot;Female&quot; )) %&gt;% mutate(agegp = case_when( AGE &lt;25 ~ &quot;&lt;25&quot;, AGE &lt;30 ~ &quot;&lt;30&quot;, AGE &lt;35 ~ &quot;&lt;35&quot;, AGE &lt;40 ~ &quot;&lt;40&quot;, AGE &lt;45 ~ &quot;&lt;45&quot;, AGE &lt;50 ~ &quot;&lt;50&quot;, AGE &lt;55 ~ &quot;&lt;55&quot;, AGE &lt;60 ~ &quot;&lt;60&quot;, TRUE ~ &quot;\\u226560&quot; # 나머지는 모두 &gt;65 (\\u2265는 크거나 같다는 symbol) )) %&gt;% group_by(agegp) %&gt;% count(heal_prob1) ## # A tibble: 18 × 3 ## # Groups: agegp [9] ## agegp heal_prob1 n ## &lt;chr&gt; &lt;dbl+lbl&gt; &lt;int&gt; ## 1 &lt;25 1 [있다] 171 ## 2 &lt;25 2 [없다] 1471 ## 3 &lt;30 1 [있다] 464 ## 4 &lt;30 2 [없다] 2734 ## 5 &lt;35 1 [있다] 655 ## 6 &lt;35 2 [없다] 3239 ## 7 &lt;40 1 [있다] 982 ## 8 &lt;40 2 [없다] 3731 ## 9 &lt;45 1 [있다] 1246 ## 10 &lt;45 2 [없다] 3999 ## 11 &lt;50 1 [있다] 1578 ## 12 &lt;50 2 [없다] 4247 ## 13 &lt;55 1 [있다] 1916 ## 14 &lt;55 2 [없다] 4400 ## 15 &lt;60 1 [있다] 2272 ## 16 &lt;60 2 [없다] 3943 ## 17 ≥60 1 [있다] 6852 ## 18 ≥60 2 [없다] 6579 한눈에 파악하기 어렵네요. 그럼 어떻게 하는 것이 좋을 까요, mutate를 통해 율을 구해보는 것이 좋겠습니다. kwcs %&gt;% filter(!is.na(heal_prob1)) %&gt;% # is.na() 즉 NA이면에서 !는 NA가 아니면이라는 뜻 select(TSEX, AGE, heal_prob1) %&gt;% mutate(sexgp=case_when( TSEX==1 ~ &quot;Men&quot;, TRUE ~ &quot;Female&quot; )) %&gt;% mutate(agegp = case_when( AGE &lt;25 ~ &quot;&lt;25&quot;, AGE &lt;30 ~ &quot;&lt;30&quot;, AGE &lt;35 ~ &quot;&lt;35&quot;, AGE &lt;40 ~ &quot;&lt;40&quot;, AGE &lt;45 ~ &quot;&lt;45&quot;, AGE &lt;50 ~ &quot;&lt;50&quot;, AGE &lt;55 ~ &quot;&lt;55&quot;, AGE &lt;60 ~ &quot;&lt;60&quot;, TRUE ~ &quot;\\u226560&quot; # 나머지는 모두 &gt;65 (\\u2265는 크거나 같다는 symbol) )) %&gt;% group_by(agegp) %&gt;% count(heal_prob1) %&gt;% mutate(prob = n/sum(n)) %&gt;% #proportion을 구함 filter(heal_prob1 == 1) # 요통이 있다고한 사람을 비율만 남김. ## # A tibble: 9 × 4 ## # Groups: agegp [9] ## agegp heal_prob1 n prob ## &lt;chr&gt; &lt;dbl+lbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 &lt;25 1 [있다] 171 0.104 ## 2 &lt;30 1 [있다] 464 0.145 ## 3 &lt;35 1 [있다] 655 0.168 ## 4 &lt;40 1 [있다] 982 0.208 ## 5 &lt;45 1 [있다] 1246 0.238 ## 6 &lt;50 1 [있다] 1578 0.271 ## 7 &lt;55 1 [있다] 1916 0.303 ## 8 &lt;60 1 [있다] 2272 0.366 ## 9 ≥60 1 [있다] 6852 0.510 요통의 유병율이 연령이 증가할 수록 점차 증가하고 있네요, 남녀의 차이가 있을 까요? 남녀별 구분을 위해 group_by( )에 sexgp를 추가했습니다 . smry1 = kwcs %&gt;% filter(!is.na(heal_prob1)) %&gt;% # is.na() 즉 NA이면에서 !는 NA가 아니면이라는 뜻 select(TSEX, AGE, heal_prob1) %&gt;% mutate(sexgp=case_when( TSEX==1 ~ &quot;Men&quot;, TRUE ~ &quot;Female&quot; )) %&gt;% mutate(agegp = case_when( AGE &lt;25 ~ &quot;&lt;25&quot;, AGE &lt;30 ~ &quot;&lt;30&quot;, AGE &lt;35 ~ &quot;&lt;35&quot;, AGE &lt;40 ~ &quot;&lt;40&quot;, AGE &lt;45 ~ &quot;&lt;45&quot;, AGE &lt;50 ~ &quot;&lt;50&quot;, AGE &lt;55 ~ &quot;&lt;55&quot;, AGE &lt;60 ~ &quot;&lt;60&quot;, TRUE ~ &quot;\\u226560&quot; # 나머지는 모두 &gt;65 (\\u2265는 크거나 같다는 symbol) )) %&gt;% group_by(sexgp, agegp) %&gt;% # 성별, 연령별 count(heal_prob1) %&gt;% mutate(prob = n/sum(n)) %&gt;% #proportion을 구함 filter(heal_prob1 == 1) # 요통이 있다고한 사람을 비율만 남김. smry1 ## # A tibble: 18 × 5 ## # Groups: sexgp, agegp [18] ## sexgp agegp heal_prob1 n prob ## &lt;chr&gt; &lt;chr&gt; &lt;dbl+lbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Female &lt;25 1 [있다] 93 0.107 ## 2 Female &lt;30 1 [있다] 266 0.173 ## 3 Female &lt;35 1 [있다] 354 0.186 ## 4 Female &lt;40 1 [있다] 450 0.207 ## 5 Female &lt;45 1 [있다] 619 0.242 ## 6 Female &lt;50 1 [있다] 831 0.268 ## 7 Female &lt;55 1 [있다] 1133 0.311 ## 8 Female &lt;60 1 [있다] 1422 0.392 ## 9 Female ≥60 1 [있다] 4339 0.590 ## 10 Men &lt;25 1 [있다] 78 0.101 ## 11 Men &lt;30 1 [있다] 198 0.119 ## 12 Men &lt;35 1 [있다] 301 0.151 ## 13 Men &lt;40 1 [있다] 532 0.209 ## 14 Men &lt;45 1 [있다] 627 0.233 ## 15 Men &lt;50 1 [있다] 747 0.274 ## 16 Men &lt;55 1 [있다] 783 0.293 ## 17 Men &lt;60 1 [있다] 850 0.329 ## 18 Men ≥60 1 [있다] 2513 0.413 summarise summarise는 colum 별로 정리하여 나타낸는 함수 입니다. 이때 주로 같이 사용하는 함수는 mean, sd, median, max, min 등이며, quantile도 많이 사용됩니다. kwcs %&gt;% summarise(mean_age = mean(AGE), std_age = sd(AGE)) ## # A tibble: 1 × 2 ## mean_age std_age ## &lt;dbl&gt; &lt;dbl&gt; ## 1 49.9 14.8 group_by와 함께 사용해 볼까요? kwcs %&gt;% filter(!is.na(heal_prob1)) %&gt;% # is.na() 즉 NA이면에서 !는 NA가 아니면이라는 뜻 select(TSEX, AGE, heal_prob1) %&gt;% mutate(sexgp=case_when( TSEX==1 ~ &quot;Men&quot;, TRUE ~ &quot;Female&quot; )) %&gt;% group_by(sexgp) %&gt;% summarise(mean_age = mean(AGE), std_age = sd(AGE)) ## # A tibble: 2 × 3 ## sexgp mean_age std_age ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Female 50.8 14.8 ## 2 Men 49.0 14.7 중요한 부분인 group_by를 한후에 group을 해제하기 위해서는 ungroup()을 해주어야 합니다. 향후 Table 만들기 등에서 활용되니 기역해 주세요. 5.8 merge, join 이번에는 두개의 테이블을 하나로 만들어 보겠습니다. tab1 &lt;- tibble(id = c(1, 2), var1 = c(&quot;a1&quot;, &quot;a2&quot;)) tab2 &lt;- tibble(id = c(2, 3), var2 = c(&quot;b1&quot;, &quot;b2&quot;)) tab1 ## # A tibble: 2 × 2 ## id var1 ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a1 ## 2 2 a2 tab2 ## # A tibble: 2 × 2 ## id var2 ## &lt;dbl&gt; &lt;chr&gt; ## 1 2 b1 ## 2 3 b2 이둘을 합쳐 보겠습니다. &gt;full join tab1 %&gt;% full_join(tab2, by=c(&quot;id&quot;)) ## # A tibble: 3 × 3 ## id var1 var2 ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 a1 &lt;NA&gt; ## 2 2 a2 b1 ## 3 3 &lt;NA&gt; b2 inner join tab1 %&gt;% inner_join(tab2, by=c(&quot;id&quot;)) ## # A tibble: 1 × 3 ## id var1 var2 ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 a2 b1 right join tab1 %&gt;% right_join(tab2, by=c(&quot;id&quot;)) ## # A tibble: 2 × 3 ## id var1 var2 ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2 a2 b1 ## 2 3 &lt;NA&gt; b2 left join tab1 %&gt;% left_join(tab2, by=c(&quot;id&quot;)) ## # A tibble: 2 × 3 ## id var1 var2 ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 a1 &lt;NA&gt; ## 2 2 a2 b1 어떻게 결과가 예상과 같았나요? 아래와 같이 정리할 수 있습니다. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
